// NOTE: the way the code generator is currently implemented is a little wonky, especially around contextual keywords and matching specific tokens.
// The current implementation works well enough for its purpose, but if you make changes, be sure to carefully check if the generated code does what you expect it to do.

File =
  StructContent*

StructContent =
  Declaration
| StructField
| Struct
| LetStatement

StructBlock =
  '{' StructContent* '}'

Declaration =
  EndiannessDeclaration
| AlignDeclaration
| SeekByDeclaration
| SeekToDeclaration
| ScopeAtDeclaration
| IfDeclaration
| AssertDeclaration
| WarnIfDeclaration
| RecoveryDeclaration

EndiannessDeclaration =
  '!' 'endian' kind:'ident' ';'

AlignDeclaration =
  '!' 'align' amount:Expr ';'

SeekByDeclaration =
  '!' 'seek' 'by' amount:Expr ';'

SeekToDeclaration =
  '!' 'seek' 'to' amount:Expr ';'

ScopeAtDeclaration =
  '!' 'scope' 'at' start:Expr ('until' end:Expr)? StructBlock

IfDeclaration = 
  '!' IfChain

IfChain =
  'if' condition:Expr then_block:StructBlock ('else' ElsePart)?

ElsePart =
  IfChain
| ElseBlock

ElseBlock =
  StructBlock

AssertDeclaration =
  '!' 'assert' Expr (':' message:Expr)? ';'

WarnIfDeclaration =
  '!' 'warn' 'if' Expr (':' message:Expr)? ';'

RecoveryDeclaration =
  '!' 'recover' 'at' Expr ';'

StructField =
  name:'ident' ParseType ( '=' expected:Expr )?

ParseType =
  NamedParseType
| BytesParseType
| RepeatParseType
| AnonymousStructParseType
| SwitchParseType

NamedParseType =
  name:'ident'

BytesParseType =
  'bytes' RepeatDecl?

RepeatParseType =
  '[' ty:ParseType ']' repetition:RepeatDecl

AnonymousStructParseType =
  StructBlock

SwitchParseType =
  'switch' scrutinee:Expr '{' SwitchParseTypeArm* '_' '=' '>' default:ParseType ','? '}'

SwitchParseTypeArm =
  val:Expr '=' '>' ParseType ','

RepeatDecl =
  RepeatLenDecl
| RepeatWhileDecl

RepeatLenDecl =
  'len' count:Expr

RepeatWhileDecl =
  'while' condition:Expr

Struct =
  'struct' name:'ident' StructBlock

LetStatement =
  'let' name:'ident' '=' Expr ';'

Expr =
  Atom
| Metavar
| ByteConcat
| ParenExpr
| PrefixExpr
| InfixExpr
| FieldAccess
| PeekExpr

Atom =
  'bin_lit'
| 'oct_lit'
| 'dec_lit'
| 'hex_lit'
| 'str_lit'
| 'true'
| 'false'
| 'ident'

Metavar =
  '$' name:'ident'

ByteConcat =
  '<' ( 'byte_lit' | 'dec_lit' | 'str_lit' )* '>'

ParenExpr =
  '(' Expr ')'

PrefixExpr =
  Op Expr

InfixExpr =
  lhs:Expr Op rhs:Expr

FieldAccess =
  Expr '.' field:'ident'

PeekExpr =
  'peek' '(' ParseType ('at' offset:Expr)? ')'

Op =
  '+'
| '-'
| '*'
| '/'
| '=='
| '!='
| '>'
| '>='
| '<'
| '<='
| '&&'
| '||'
| '&'
| '|'
| '^'
