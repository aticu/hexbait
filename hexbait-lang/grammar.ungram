// NOTE: the way the code generator is currently implemented is a little wonky, especially around contextual keywords and matching specific tokens.
// The current implementation works well enough for its purpose, but if you make changes, be sure to carefully check if the generated code does what you expect it to do.

File =
  StructContent*

StructContent =
  Declaration
| StructField
| Struct
| LetStatement

Declaration =
  EndiannessDeclaration
| AlignDeclaration
| SeekByDeclaration
| SeekToDeclaration
| ScopeAtDeclaration
| AssertDeclaration
| WarnIfDeclaration

EndiannessDeclaration =
  '!' 'endian' kind:'ident' ';'

AlignDeclaration =
  '!' 'align' amount:Expr ';'

SeekByDeclaration =
  '!' 'seek' 'by' amount:Expr ';'

SeekToDeclaration =
  '!' 'seek' 'to' amount:Expr ';'

ScopeAtDeclaration =
  '!' 'scope' 'at' start:Expr ('until' end:Expr)? '{' StructContent* '}'

AssertDeclaration =
  '!' 'assert' Expr (':' message:Expr)? ';'

WarnIfDeclaration =
  '!' 'warn' 'if' Expr (':' message:Expr)? ';'

StructField =
  name:'ident' ParseType ( '=' expected:Expr )?

ParseType =
  NamedParseType
| BytesParseType
| RepeatParseType
| AnonymousStructParseType
| SwitchParseType

NamedParseType =
  name:'ident'

BytesParseType =
  'bytes' RepeatDecl?

RepeatParseType =
  '[' ty:ParseType ']' repetition:RepeatDecl

AnonymousStructParseType =
  '{' StructContent* '}'

SwitchParseType =
  'switch' scrutinee:Expr '{' SwitchParseTypeArm* '_' '=' '>' default:ParseType ','? '}'

SwitchParseTypeArm =
  val:Expr '=' '>' ParseType ','

RepeatDecl =
  RepeatLenDecl
| RepeatWhileDecl

RepeatLenDecl =
  'len' count:Expr

RepeatWhileDecl =
  'while' condition:Expr

Struct =
  'struct' name:'ident' '{' StructContent* '}'

LetStatement =
  'let' name:'ident' '=' Expr ';'

Expr =
  Atom
| Metavar
| ByteConcat
| ParenExpr
| PrefixExpr
| InfixExpr
| FieldAccess
| PeekExpr

Atom =
  'bin_lit'
| 'oct_lit'
| 'dec_lit'
| 'hex_lit'
| 'str_lit'
| 'true'
| 'false'
| 'ident'

Metavar =
  '$' name:'ident'

ByteConcat =
  '<' ( 'byte_lit' | 'dec_lit' | 'str_lit' )* '>'

ParenExpr =
  '(' Expr ')'

PrefixExpr =
  Op Expr

InfixExpr =
  lhs:Expr Op rhs:Expr

FieldAccess =
  Expr '.' field:'ident'

PeekExpr =
  'peek' '(' ParseType ('at' offset:Expr)? ')'

Op =
  '+'
| '-'
| '*'
| '/'
| '=='
| '!='
| '>'
| '>='
| '<'
| '<='
| '&&'
| '||'
| '&'
| '|'
| '^'
